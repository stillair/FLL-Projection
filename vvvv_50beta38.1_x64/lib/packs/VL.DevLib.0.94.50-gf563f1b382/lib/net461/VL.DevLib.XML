<?xml version="1.0"?>
<doc>
    <assembly>
        <name>VL.DevLib</name>
    </assembly>
    <members>
        <member name="M:VL.Lib.Collections.Compare.By``2(System.Func{``0,``1})">
            <summary>
            Creates an equality comparer from a key selector delegate
            </summary>
            <typeparam name="T">Item type</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="selector">The selector.</param>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.IntersectByKey``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Produces the set intersection of two sequences by using a key selector delegate to compare values
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TKey"></typeparam>
            <param name="input"></param>
            <param name="input2"></param>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.UnionByKey``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Produces the set union of two sequences by using a key selector delegate to compare values
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TKey"></typeparam>
            <param name="input"></param>
            <param name="input2"></param>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.ExceptByKey``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Produces the set difference of two sequences by using a key selector delegate to compare values
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TKey"></typeparam>
            <param name="input"></param>
            <param name="input2"></param>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.SplitAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Collections.Generic.IEnumerable{``0}@,System.Collections.Generic.IEnumerable{``0}@)">
            <summary>
            Splits the sequence at the given index into two sequences
            </summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <param name="index"></param>
            <param name="output"></param>
            <param name="output2"></param>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.ToSequence``1(``0)">
            <summary>
            Returns the input as a Sequence with one element
            </summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.UnZip``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0}@,System.Collections.Generic.IEnumerable{``0}@)">
            <summary>
            The inverse of Zip. Interprets the input sequence as being interleaved and untangles it
            </summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <param name="output"></param>
            <param name="output2"></param>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.ZipIt``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>
            Interleaves the two input sequences. To get the functionality as defined in LINQ use Zip (LINQ)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <param name="input2"></param>
            <param name="useMinCount"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})">
            <summary>
            Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TAccumulate"></typeparam>
            <param name="input"></param>
            <param name="seed"></param>
            <param name="accumulator"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.Cast``1(System.Collections.IEnumerable)">
            <summary>
            Casts the elements of an System.Collections.IEnumerable to the specified type
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Concatenates all incoming sequences to one sequence
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="input"></param>
            <param name="input2"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.Count``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the number of elements in a sequence
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.Count``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns a number that represents how many elements in the specified sequence satisfy a condition
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="input"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Returns the elements of the specified sequence or the specified value in a singleton collection if the sequence is empty
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="input"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.Distinct``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns distinct elements from a sequence by using the default equality comparer to compare values
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.Empty``1">
            <summary>
            Returns an empty sequence
            </summary>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Produces the set difference of two sequences by using the default equality comparer to compare values
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="input"></param>
            <param name="input2"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TKey"></typeparam>
            <param name="input"></param>
            <param name="keySelector"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Produces the set intersection of two sequences by using the default equality comparer to compare values
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="input"></param>
            <param name="input2"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.OfType``1(System.Collections.IEnumerable)">
            <summary>
            Filters the elements of a sequence based on a specified type
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Sorts the elements of a sequence in ascending order according to a key
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TKey"></typeparam>
            <param name="input"></param>
            <param name="keySelector"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Sorts the elements of a sequence in descending order according to a key
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TKey"></typeparam>
            <param name="input"></param>
            <param name="keySelector"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.Reverse``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Inverts the order of the elements in a sequence
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.Project``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})">
            <summary>
            Projects each element of a sequence into a new form by incorporating the element's index
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="input"></param>
            <param name="transformer"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.Project``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Projects each element of a sequence to a sequence, and flattens the resulting sequences into one sequence. The index of each source element is used in the projected form of that element
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="input"></param>
            <param name="transformer"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.Skip``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Bypasses a specified number of elements in a sequence and then returns the remaining elements
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="input"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>
            Bypasses elements in a sequence as long as a specified condition is true and then returns the remaining elements. The element's index is used in the logic of the predicate function
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="input"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.Take``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Returns a specified number of contiguous elements from the start of a sequence
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="input"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>
            Returns elements from a sequence as long as a specified condition is true. The element's index is used in the logic of the predicate function
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="input"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Performs a subsequent ordering of the elements in a sequence in ascending order according to a key
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TKey"></typeparam>
            <param name="input"></param>
            <param name="keySelector"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Performs a subsequent ordering of the elements in a sequence in descending order, according to a key
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TKey"></typeparam>
            <param name="input"></param>
            <param name="keySelector"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.ToArray``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an array from a sequence
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Produces the set union of two sequences by using the default equality comparer
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="input"></param>
            <param name="input2"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>
            Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="input"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.EnumerableNodes.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})">
            <summary>
            Applies a specified function to the corresponding elements of two sequences, producing a sequence of the results
            </summary>
            <typeparam name="TFirst"></typeparam>
            <typeparam name="TSecond"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="input"></param>
            <param name="input2"></param>
            <param name="resultSelector"></param>
            <returns></returns>
        </member>
        <member name="T:VL.Lib.Reactive.ObservableNodes">
            <summary>
            Contains a set of static nodes working on observables.
            </summary>
        </member>
        <member name="M:VL.Lib.Reactive.ObservableNodes.Empty``1">
            <summary>
            Returns an empty observable sequence
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Reactive.ObservableNodes.Never``1">
            <summary>
            Returns a non-terminating observable sequence, which can be used to denote an infinite duration (e.g. when using reactive joins)
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Reactive.ObservableNodes.PubRefCount``1(System.IObservable{``0})">
            <summary>
            Returns an observable sequence that stays connected to the source as long as there is at least one subscription to the observable sequence
            and shares only one single subscription to the underlying sequence.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Reactive.ObservableNodes.OnErrorTerminate``1(System.IObservable{``0})">
            <summary>
            Terminates the sequence upon successful or exceptional termination
            </summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Reactive.ObservableNodes.BackoffAndRetry``1(System.IObservable{``0},System.Double)">
            <summary>
            Repeats the source observable sequence until it successfully terminates. Each subsequent subscription will be delayed by the given amount of time in seconds
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="delayInSeconds"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Reactive.ObservableNodes.BackoffAndRetry``1(System.IObservable{``0},System.Int32,System.Double)">
            <summary>
            Repeats the source observable sequence the specified number of times or until it successfully terminates. Each subsequent subscription will be delayed by the given amount of time in seconds
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="retryCount"></param>
            <param name="delay"></param>
            <returns></returns>
        </member>
        <member name="T:VL.Lib.Reactive.ObservableNodes.BlockingReceiver`1">
            <summary>
            Receives values from an input sequence. Each call to Receive blocks until the next value is produced.
            </summary>
            <typeparam name="T">The element type.</typeparam>
        </member>
        <member name="M:VL.Lib.Reactive.ObservableNodes.BlockingReceiver`1.Receive(System.IObservable{`0},`0,System.Threading.CancellationToken,System.Boolean@)">
            <summary>
            Blocks until the next item is produced by the input sequence and returns the value.
            Since the call is blocking make sure to use it on a different thread than the producer and provide it with a proper cancellation token.
            Without a token the method will return immediately with the default value.
            </summary>
            <param name="input">The sequence to receive values from.</param>
            <param name="defaultValue">The value to return in case the receive call fails.</param>
            <param name="cancellationToken">The cancellation token to cancel the blocking receive call.</param>
            <param name="success">Whether or not a value was received.</param>
            <returns>The received value.</returns>
        </member>
        <member name="T:VL.Lib.Reactive.SafeScheduler">
            <summary>
            Provides wrapped versions of all the standard schedulers of RX with VL exception handling.
            </summary>
        </member>
        <member name="P:VL.Lib.Reactive.SafeScheduler.CurrentSynchronizationContext">
            <summary>
            Gets a scheduler that schedules work as soon as possible on the current thread.
            </summary>
        </member>
        <member name="F:VL.Lib.Reactive.SafeScheduler.Default">
            <summary>
            Gets a scheduler that schedules work on the platform's default scheduler.
            </summary>
        </member>
        <member name="P:VL.Lib.Reactive.SafeScheduler.CurrentThread">
            <summary>
            Gets a scheduler that schedules work as soon as possible on the current thread.
            </summary>
        </member>
        <member name="F:VL.Lib.Reactive.SafeScheduler.Immediate">
            <summary>
            Gets a scheduler that schedules work immediately on the current thread.
            </summary>
        </member>
        <member name="F:VL.Lib.Reactive.SafeScheduler.NewThread">
            <summary>
            Gets a scheduler that schedules work on a new thread using default thread creation options.
            </summary>
        </member>
        <member name="F:VL.Lib.Reactive.SafeScheduler.TaskPool">
            <summary>
            Gets a scheduler that schedules work on Task Parallel Library (TPL) task pool using the default TaskScheduler.
            </summary>
        </member>
        <member name="F:VL.Lib.Reactive.SafeScheduler.ThreadPool">
            <summary>
            Gets a scheduler that schedules work on the thread pool.
            </summary>
        </member>
        <member name="M:VL.Lib.Reactive.SafeScheduler.CatchAndReportRuntimeExceptions(System.Reactive.Concurrency.IScheduler)">
            <summary>
            Returns a scheduler that wraps the original scheduler, adding VL exception handling for scheduled actions.
            </summary>
        </member>
    </members>
</doc>
